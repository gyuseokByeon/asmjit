// AsmJit - Machine code generation for C++
//
//  * Official AsmJit Home Page: https://asmjit.com
//  * Official Github Repository: https://github.com/asmjit/asmjit
//
// Copyright (c) 2008-2020 The AsmJit Authors
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

#ifndef ASMJIT_CORE_H_INCLUDED
#define ASMJIT_CORE_H_INCLUDED

//! Root namespace used by AsmJit.
namespace asmjit {

// ============================================================================
// [Documentation - mainpage]
// ============================================================================

//! \mainpage API Reference
//!
//! AsmJit C++ API reference documentation generated by Doxygen.
//!
//! AsmJit library uses one global namespace called \ref asmjit, which provides
//! the whole functionality. Core functionality is within \ref asmjit namespace
//! and arthitecture specific functionality is always in its own namespace. For
//! example \ref asmjit::x86 provides both 32-bit and 64-bit X86 code generation.
//!
//! \section main_groups Documentation Groups
//!
//! AsmJit documentation is structured into groups. Groups can be followed in
//! order to learn AsmJit, but knowledge from multiple groups is required to
//! use AsmJit properly:
//!
//! $$DOCS_GROUP_OVERVIEW$$
//!
//! \note It's important to understand that in order to learn AsmJit all groups
//! are important. Some groups can be omitted if a particular tool is out of
//! interest - for example \ref asmjit_assembler users don't need to know about
//! \ref asmjit_builder, but it's not the opposite. \ref asmjit_builder users
//! must know about \ref asmjit_assembler as it also uses operands, labels, and
//! other concepts. Similarly \ref asmjit_compiler users must know how both \ref
//! asmjit_assembler and \ref asmjit_builder tools work.
//!
//! \section main_recommendations Recommendations
//!
//! The following steps are recommended for all AsmJit users:
//!
//!   - Make sure that you use \ref Logger, see \ref asmjit_logging.
//!   - Make sure that you use \ref ErrorHandler, see \ref asmjit_error_handling.
//!   - Instruction validation in your debug builds can reveal problems too.
//!
//! The reason for using \ref Logger and \ref ErrorHandler is that they provide
//! a very useful information about what's happening inside emitters. In many
//! cases the information provided by these two is crucial to quickly fix issues
//! that happen during development (for example wrong instruction, address, or
//! register used). In addition, output from \ref Logger is always necessary
//! when filling bug reports. In other words, using logging and proper error
//! handling can save a lot of time during the development.
//!
//! \section main_other Other Pages
//!
//!   - <a href="annotated.html">Class List</a> - List of classes sorted alphabetically
//!   - <a href="namespaceasmjit.html">AsmJit Namespace</a> - List of symbols provided by `asmjit` namespace

// ============================================================================
// [Documentation - asmjit_core]
// ============================================================================

//! \defgroup asmjit_core Core
//! \brief Globals, code storage, and emitter interface.
//!
//! ### Overview
//!
//! AsmJit library uses \ref CodeHolder to hold code and emitters inheriting
//! from \ref BaseEmitter to emit code. CodeHolder uses containers to manage
//! its data:
//!
//!   - \ref Section - stores information about a code or data section.
//!   - \ref CodeBuffer - stores actual code or data, part of \ref Section.
//!   - \ref LabelEntry - stores information about a label - its name, offset,
//!     section where it belongs to, and other bits.
//!   - \ref LabelLink - stores information about yet unbound label, which was
//!     already used by the assembler.
//!   - \ref RelocEntry - stores information about a relocation.
//!   - \ref AddressTableEntry - stores information about an address, which was
//!     used in a jump or call. Such address may need relocation.
//!
//! To generate code you would need to instantiate at least the following classes:
//!
//!   - \ref CodeHolder - to hold code during code generation.
//!   - \ref BaseEmitter - to emit code into \ref CodeHolder.
//!   - \ref Target - most likely \ref JitRuntime to keep the generated code in
//!     executable memory. \ref Target can be customized by inheriting from it.
//!
//! Globals:
//!
//!   - \ref Globals - namespace that provides global constants.
//!   - \ref ByteOrder - byte-order constants and functionality.
//!
//! \note CodeHolder examples use \ref x86::Assembler as abstract interfaces cannot
//! be used to generate code.
//!
//! ### CodeHolder & Emitters
//!
//! The example below shows how the mentioned classes interact to generate X86 code:
//!
//! ```
//! #include <asmjit/x86.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! // Signature of the generated function.
//! typedef int (*Func)(void);
//!
//! int main() {
//!   JitRuntime rt;                    // Runtime specialized for JIT code execution.
//!
//!   CodeHolder code;                  // Holds code and relocation information.
//!   code.init(rt.codeInfo());         // Initialize code to match the JIT runtime.
//!
//!   x86::Assembler a(&code);          // Create and attach x86::Assembler to code.
//!   a.mov(x86::eax, 1);               // Move one to eax register.
//!   a.ret();                          // Return from function.
//!   // ----> x86::Assembler is no longer needed from here and can be destroyed <----
//!
//!   Func fn;                          // Holds address to the generated function.
//!   Error err = rt.add(&fn, &code);   // Add the generated code to the runtime.
//!   if (err) return 1;                // Handle a possible error returned by AsmJit.
//!   // ----> CodeHolder is no longer needed from here and can be destroyed <----
//!
//!   int result = fn();                // Execute the generated code.
//!   printf("%d\n", result);           // Print the resulting "1".
//!
//!   // All classes use RAII, all resources will be released before `main()` returns,
//!   // the generated function can be, however, released explicitly if you intend to
//!   // reuse or keep the runtime alive, which you should in a production-ready code.
//!   rt.release(fn);
//!
//!   return 0;
//! }
//! ```
//!
//! The example above used \ref x86::Assembler as an emitter. AsmJit provides the
//! following emitters that offer various levels of abstraction:
//!
//!   - \ref asmjit_assembler - Low-level emitter that emits directly to \ref CodeBuffer.
//!   - \ref asmjit_builder - Low-level emitter that emits to a \ref BaseNode list.
//!   - \ref asmjit_compiler - High-level emitter that provides register allocation.
//!
//! ### Targets and JitRuntime
//!
//! AsmJit's \ref Target is an interface that provides basic target abstraction.
//! At the moment AsmJit provides only one implementation called \ref JitRuntime,
//! which as the name suggests provides JIT code target and execution runtime.
//! \ref JitRuntime provides all the necessary stuff to implement a simple JIT
//! compiler with basic memory management. It only provides \ref JitRuntime::add()
//! and \ref JitRuntime::release() functions that are used to either add code
//! to the runtime or release it. \ref JitRuntime doesn't do any decisions on
//! when the code should be released, the decision is up to the developer.
//!
//! See more at \ref asmjit_virtual_memory group.
//!
//! ### More About CodeInfo
//!
//! In the previous example the \ref CodeInfo is retrieved from \ref JitRuntime.
//! It's logical as \ref JitRuntime always returns a \ref CodeInfo that is compatible
//! with the host runtime environment. For example if your application runs in 64-bit
//! mode the \ref CodeInfo returned will use \ref ArchInfo::kIdX64 architecture in
//! contrast to \ref ArchInfo::kIdX86, which will be used in 32-bit mode.
//!
//! AsmJit allows to setup \ref CodeInfo manually and to select a different
//! architecture when necessary. So let's do something else this time, let's always
//! generate a 32-bit code and print its binary representation. To do that, we can
//! create our own \ref CodeInfo and initialize it to \ref ArchInfo::kIdX86. CodeInfo
//! will populate all basic fields just based on the architecture we provide, so it's
//! super-easy:
//!
//! ```
//! #include <asmjit/x86.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! int main(int argc, char* argv[]) {
//!   using namespace asmjit::x86;      // Easier access to x86/x64 registers.
//!
//!   CodeHolder code;                  // Create a CodeHolder.
//!   CodeInfo info(ArchInfo::kIdX86);  // Initialize CodeInfo for 32-bit X86.
//!   code.init(info);                  // Initialize CodeHolder for 32-bit X86.
//!
//!   // Generate a 32-bit function that sums 4 floats and looks like:
//!   //   void func(float* dst, const float* a, const float* b)
//!   x86::Assembler a(&code);          // Create and attach x86::Assembler to `code`.
//!
//!   a.mov(eax, dword_ptr(esp, 4));    // Load the destination pointer.
//!   a.mov(ecx, dword_ptr(esp, 8));    // Load the first source pointer.
//!   a.mov(edx, dword_ptr(esp, 12));   // Load the second source pointer.
//!
//!   a.movups(xmm0, ptr(ecx));         // Load 4 floats from [ecx] to XMM0.
//!   a.movups(xmm1, ptr(edx));         // Load 4 floats from [edx] to XMM1.
//!   a.addps(xmm0, xmm1);              // Add 4 floats in XMM1 to XMM0.
//!   a.movups(ptr(eax), xmm0);         // Store the result to [eax].
//!   a.ret();                          // Return from function.
//!
//!   // We have no Runtime this time, it's on us what we do with the code.
//!   // CodeHolder stores code in Section, which provides some basic properties
//!   // and CodeBuffer structure. We are interested in section's CodeBuffer.
//!   //
//!   // NOTE: The first section is always '.text', it can be retrieved by
//!   // code.sectionById(0) or simply by code.textSection().
//!   CodeBuffer& buffer = code.textSection()->buffer();
//!
//!   // Print the machine-code generated or do something else with it...
//!   //   8B4424048B4C24048B5424040F28010F58010F2900C3
//!   for (size_t i = 0; i < buffer.length; i++)
//!     printf("%02X", buffer.data[i]);
//!
//!   return 0;
//! }
//! ```
//!
//! ### Explicit Code Relocation
//!
//! CodeInfo contains much more information than just the target architecture.
//! It can be configured to specify a base-address (or a virtual base-address
//! in a linker terminology), which could be static (useful when you know the
//! location where the target's machine code will be) or dynamic. AsmJit assumes
//! dynamic base-address by default and relocates the code held by \ref CodeHolder
//! to a user provided address on-demand. To be able to relocate to a user
//! provided address it needs to store some information about relocations, which
//! is represented by \ref RelocEntry. Relocation entries are only required if
//! you call external functions from the generated code that cannot be encoded
//! by using a 32-bit displacement (64-bit displacements are not provided by aby
//! supported architecture).
//!
//! There is also a concept called \ref LabelLink - label link is a lightweight
//! data structure that doesn't have any identifier and is stored in \ref LabelEntry
//! as a single-linked list. Label link represents either unbound yet used label
//! and cross-sections links (only relevant to code that uses multiple sections).
//! Since crossing sections is something that cannot be resolved immediately these
//! links persist until offsets of these sections are assigned and until
//! \ref CodeHolder::resolveUnresolvedLinks() is called. It's an error if you end
//! up with code that has unresolved label links after flattening. You can verify
//! it by calling \ref CodeHolder::hasUnresolvedLinks(), which inspects the value
//! returned by \ref CodeHolder::unresolvedLinkCount().
//!
//! AsmJit can flatten code that uses multiple sections by assigning each section
//! an incrementing offset that respects its alignment. Use \ref CodeHolder::flatten()
//! to do that. After the sections are flattened their offsets and virtual-sizes
//! are adjusted to respect each section's buffer size and alignment. The \ref
//! CodeHolder::resolveUnresolvedLinks() function must be called before relocating
//! the code held by \ref CodeHolder. You can also flatten your code manually by
//! iterating over all sections and calculating their offsets (relative to base)
//! by your own algorithm. In that case \ref CodeHolder::flatten() should not be
//! called, however, \ref CodeHolder::resolveUnresolvedLinks() should be.
//!
//! The example below shows how to use a built-in virtual memory allocator
//! \ref JitAllocator instead of using \ref JitRuntime (just in case you want
//! to use your own memory management) and how to relocate the generated code
//! into your own memory block - you can use your own virtual memory allocator
//! if you prefer that, but that's OS specific and not covered by the documentation.
//!
//! The following code is similar to the previous one, but implements a function
//! working in both 32-bit and 64-bit environments:
//!
//! ```
//! #include <asmjit/x86.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! typedef void (*SumIntsFunc)(int* dst, const int* a, const int* b);
//!
//! int main() {
//!   CodeHolder code;                  // Create a CodeHolder.
//!   CodeInfo info(ArchInfo::kIdX86);  // Initialize CodeInfo for 32-bit X86.
//!   code.init(info);                  // Initialize CodeHolder for 32-bit X86.
//!
//!   x86::Assembler a(&code);          // Create and attach x86::Assembler to `code`.
//!
//!   // Generate a function runnable in both 32-bit and 64-bit architectures:
//!   bool isX86 = ASMJIT_ARCH_X86 == 32;
//!
//!   // Signature: 'void func(int* dst, const int* a, const int* b)'.
//!   x86::Gp dst;
//!   x86::Gp src_a;
//!   x86::Gp src_b;
//!
//!   // Handle the difference between 32-bit and 64-bit calling conventions
//!   // (arguments passed through stack vs. arguments passed by registers).
//!   if (isX86) {
//!     dst   = x86::eax;
//!     src_a = x86::ecx;
//!     src_b = x86::edx;
//!     a.mov(dst  , x86::dword_ptr(x86::esp, 4));
//!     a.mov(src_a, x86::dword_ptr(x86::esp, 8));
//!     a.mov(src_b, x86::dword_ptr(x86::esp, 12));
//!   }
//!   else {
//!   #if defined(_WIN32)
//!     dst   = x86::rcx;               // First argument  (destination pointer).
//!     src_a = x86::rdx;               // Second argument (source 'a' pointer).
//!     src_b = x86::r8;                // Third argument  (source 'b' pointer).
//!   #else
//!     dst   = x86::rdi;               // First argument  (destination pointer).
//!     src_a = x86::rsi;               // Second argument (source 'a' pointer).
//!     src_b = x86::rdx;               // Third argument  (source 'b' pointer).
//!   #endif
//!   }
//!
//!   a.movdqu(x86::xmm0, x86::ptr(src_a)); // Load 4 ints from [src_a] to XMM0.
//!   a.movdqu(x86::xmm1, x86::ptr(src_b)); // Load 4 ints from [src_b] to XMM1.
//!   a.paddd(x86::xmm0, x86::xmm1);        // Add 4 ints in XMM1 to XMM0.
//!   a.movdqu(x86::ptr(dst), x86::xmm0);   // Store the result to [dst].
//!   a.ret();                              // Return from function.
//!
//!   // Even when we didn't use multiple sections AsmJit could insert one section
//!   // called '.addrtab' (address table section), which would be filled by data
//!   // required by relocations (absolute jumps and calls). You can omit this code
//!   // if you are 100% sure your code doesn't contain multiple sections and
//!   // such relocations. You can use `CodeHolder::hasAddressTable()` to verify
//!   // whether the address table section does exist.
//!   code.flatten();
//!   code.resolveUnresolvedLinks();
//!
//!   // After the code was generated it can be relocated manually to any memory
//!   // location, however, we need to know it's size before we perform memory
//!   // allocation. `CodeHolder::codeSize()` returns the worst estimated code
//!   // size in case that relocations are not possible without trampolines (in
//!   // that case some extra code at the end of the current code buffer is
//!   // generated during relocation).
//!   size_t estimatedSize = code.codeSize();
//!
//!   // Instead of rolling up our own memory allocator we can use the one AsmJit
//!   // provides. It's decoupled so you don't need to use `JitRuntime` for that.
//!   JitAllocator allocator;
//!
//!   // Allocate an executable virtual memory and handle a possible failure.
//!   void* p = allocator.alloc(estimatedSize);
//!   if (!p)
//!     return 0;
//!
//!   // Now relocate the code to the address provided by the memory allocator.
//!   // Please note that this DOESN'T COPY anything to `p`. This function will
//!   // store the address in CodeInfo and use relocation entries to patch the
//!   // existing code in all sections to respect the base address provided.
//!   code.relocateToBase((uint64_t)p);
//!
//!   // This is purely optional. There are cases in which the relocation can omit
//!   // unneeded data, which would shrink the size of address table. If that
//!   // happened the codeSize returned after relocateToBase() would be smaller
//!   // than the originally `estimatedSize`.
//!   size_t codeSize = code.codeSize();
//!
//!   // This will copy code from all sections to `p`. Iterating over all sections
//!   // and calling `memcpy()` would work as well, however, this function supports
//!   // additional options that can be used to also zero pad sections' virtual
//!   // size, etc.
//!   //
//!   // With some additional features, copyFlattenData() does roughly this:
//!   //   for (Section* section : code.sections())
//!   //     memcpy((uint8_t*)p + section->offset(),
//!   //            section->data(),
//!   //            section->bufferSize());
//!   code.copyFlattenedData(p, codeSize, CodeHolder::kCopyWithPadding);
//!
//!   // Execute the generated function.
//!   int inA[4] = { 4, 3, 2, 1 };
//!   int inB[4] = { 1, 5, 2, 8 };
//!   int out[4];
//!
//!   // This code uses AsmJit's ptr_as_func<> to cast between void* and SumIntsFunc.
//!   ptr_as_func<SumIntsFunc>(p)(out, inA, inB);
//!
//!   // Prints {5 8 4 9}
//!   printf("{%d %d %d %d}\n", out[0], out[1], out[2], out[3]);
//!
//!   // Release 'p' is it's no longer needed. It will be destroyed with 'vm'
//!   // instance anyway, but it's a good practice to release it explicitly
//!   // when you know that the function will not be needed anymore.
//!   allocator.release(p);
//!
//!   return 0;
//! }
//! ```
//!
//! If you know the base-address in advance (before the code generation) the
//! \ref CodeInfo::setBaseAddress() function can be used to setup it. In that
//! case the Assembler will know the absolute position of each instruction and
//! would be able to use it during instruction encoding to prevent relocations
//! where possible. The following example shows how to configure the base address:
//!
//! ```
//! #include <asmjit/x86.h>
//! #include <stdio.h>
//!
//! void initializeCodeHolder(CodeHolder& code) {
//!   // Configure CodeInfo with base address.
//!   CodeInfo info(...);
//!   info.setBaseAddress(uint64_t(0x1234));
//!
//!   // initialize CodeHolder with custom CodeInfo.
//!   code.init(ci);
//! }
//! ```

// ============================================================================
// [Documentation - asmjit_arch_and_cpu]
// ============================================================================

//! \defgroup asmjit_arch_and_cpu Arch & CPU
//! \brief Architecture & CPU information.


// ============================================================================
// [Documentation - asmjit_assembler]
// ============================================================================

//! \defgroup asmjit_assembler Assembler
//! \brief Assembler interface and operands.
//!
//! ### Overview
//!
//! AsmJit's Assembler is used to emit machine code directly into a \ref
//! CodeBuffer. In general, code generation with assembler requires the knowledge
//! of the following:
//!
//!   - \ref BaseAssembler and architecture-specific assemblers:
//!     - \ref x86::Assembler - Assembler specific to X86 architecture
//!   - \ref Operand and its variations:
//!     - \ref BaseReg - Base class for a register operand, inherited by:
//!        - \ref x86::Reg - Register operand specific to X86 architecture.
//!     - \ref BaseMem - Base class for a memory operand, inherited by:
//!        - \ref x86::Mem - Memory operand specific to X86 architecture.
//!     - \ref Imm - Immediate (value) operand.
//!     - \ref Label - Label operand.
//!
//! \note Assembler examples use \ref x86::Assembler as abstract interfaces cannot
//! be used to generate code.
//!
//! ### Operand Basics
//!
//! Let's start with operands. \ref Operand is a data structure that defines a
//! data layout of any operand. It can be inherited, but any class inheriting
//! it cannot add any members to it, only the existing layout can be reused.
//! AsmJit allows to construct operands dynamically, to store them, and to query
//! a complete information about them at run-time. Operands are small (always 16
//! bytes per \ref Operand) and can be copied and passed by value. Please never
//! allocate individual operands dynamically by using a `new` keyword - it would
//! work, but then you would have to be responsible for deleting such operands.
//! In AsmJit operands are always part of some other data structures like \ref
//! InstNode, which is part of \ref asmjit_builder tool.
//!
//! Operands contain only identifiers, but not pointers to any code-generation data.
//! For example \ref Label operand only provides label identifier, but not a pointer
//! to \ref LabelEntry structure. In AsmJit such IDs are used to link stuff together
//! without having to deal with pointers.
//!
//! AsmJit's operands all inherit from a base class called \ref Operand. Operands
//! have the following properties that are commonly accessible by getters and setters:
//!
//!   - \ref Operand - Base operand, which only provides accessors that are common
//!     to all operand types.
//!   - \ref BaseReg - Describes either physical or virtual register. Physical
//!     registers have id that matches the target's machine id directly whereas
//!     virtual registers must be allocated into physical registers by a register
//!     allocator pass. Register operand provides:
//!     - Register Type - Unique id that describes each possible register provided
//!       by the target architecture - for example X86 backend provides \ref
//!       x86::Reg::RegType, which defines all variations of general purpose registers
//!       (GPB-LO, GPB-HI, GPW, GPD, and GPQ) and all types of other registers like K,
//!       MM, BND, XMM, YMM, and ZMM.
//!     - Register Group - Groups multiple register types under a single group - for
//!       example all general-purpose registers (of all sizes) on X86 are part of
//!       \ref x86::Reg::kGroupGp and all SIMD registers (XMM, YMM, ZMM) are part
//!       of \ref x86::Reg::kGroupVec.
//!     - Register Size - Contains the size of the register in bytes. If the size
//!       depends on the mode (32-bit vs 64-bit) then generally the higher size is
//!       used (for example RIP register has size 8 by default).
//!     - Register Id - Contains physical or virtual id of the register.
//!   - \ref BaseMem - Used to reference a memory location. Memory operand provides:
//!     - Base Register - A base register type and id (physical or virtual).
//!     - Index Register - An index register type and id (physical or virtual).
//!     - Offset - Displacement or absolute address to be referenced (32-bit if base
//!       register is used and 64-bit if base register is not used).
//!     - Flags that can describe various architecture dependent information (like
//!       scale and segment-override on X86).
//!   - \ref Imm - Immediate values are usually part of instructions (encoded within
//!     the instruction itself) or data.
//!   - \ref Label - used to reference a location in code or data. Labels must be
//!      created by the \ref BaseEmitter or by \ref CodeHolder. Each label has its
//!      unique id per \ref CodeHolder instance.
//!
//! ### Operand Manipulation
//!
//! AsmJit allows to construct operands dynamically, to store them, and to query
//! a complete information about them at run-time. Operands are small (always 16
//! bytes per `Operand`) and should be always copied (by value) if you intend to
//! store them (don't create operands by using `new` keyword, it's not recommended).
//! Operands are safe to be passed to `memcpy()` and `memset()`, which becomes
//! handy when working with arrays of operands. If you set all members of an \ref
//! Operand to zero the operand would become NONE operand, which is the same as a
//! default constructed Operand.
//!
//! The example below illustrates how operands can be used and modified even
//! without using any other code generation classes. The example uses X86
//! architecture-specific operands.
//!
//! ```
//! #include <asmjit/x86.h>
//!
//! using namespace asmjit;
//!
//! // Registers can be copied, it's a common practice.
//! x86::Gp dstRegByValue() { return x86::ecx; }
//!
//! void usingOperandsExample(x86::Assembler& a) {
//!   // Gets `ecx` register returned by a function.
//!   x86::Gp dst = dstRegByValue();
//!   // Gets `rax` register directly from the provided `x86` namespace.
//!   x86::Gp src = x86::rax;
//!   // Constructs `r10` dynamically.
//!   x86::Gp idx = x86::gpq(10);
//!   // Constructs [src + idx] memory address - referencing [rax + r10].
//!   x86::Mem m = x86::ptr(src, idx);
//!
//!   // Examine `m`: Returns `x86::Reg::kTypeGpq`.
//!   m.indexType();
//!   // Examine `m`: Returns 10 (`r10`).
//!   m.indexId();
//!
//!   // Reconstruct `idx` stored in mem:
//!   x86::Gp idx_2 = x86::Gp::fromTypeAndId(m.indexType(), m.indexId());
//!
//!   // True, `idx` and idx_2` are identical.
//!   idx == idx_2;
//!
//!   // Possible - op will still be the same as `m`.
//!   Operand op = m;
//!   // True (can be casted to BaseMem or architecture-specific Mem).
//!   op.isMem();
//!
//!   // True, `op` is just a copy of `m`.
//!   m == op;
//!
//!   // Static cast is fine and valid here.
//!   static_cast<BaseMem&>(op).addOffset(1);
//!   // However, using `as<T>()` to cast to a derived type is preferred.
//!   op.as<BaseMem>().addOffset(1);
//!   // False, `op` now points to [rax + r10 + 2], which is not [rax + r10].
//!   m == op;
//!
//!   // Emitting 'mov' - type safe way.
//!   a.mov(dst, m);
//!   // Not possible, `mov` doesn't provide mov(x86::Gp, Operand) overload.
//!   a.mov(dst, op);
//!
//!   // Type-unsafe, but possible.
//!   a.emit(x86::Inst::kIdMov, dst, m);
//!   // Also possible, `emit()` is typeless and can be used with raw Operand.
//!   a.emit(x86::Inst::kIdMov, dst, op);
//! }
//! ```
//!
//! Some operands have to be created explicitly by emitters. For example labels
//! must be created by \ref BaseEmitter::newLabel(), which creates a label entry
//! and returns a \ref Label operand with the id that refers to it. Such label
//! then can be used by emitters.
//!
//! ### Memory Operands
//!
//! Some architectures like X86 provide a complex memory addressing model that
//! allows to encode addresses having a BASE register, INDEX register with a
//! possible scale (left shift), and displacement (called offset in AsmJit).
//! Memory address on X86 can also specify memory segment (segment-override in
//! X86 terminology) and some instructions (gather / scatter) require INDEX to
//! be a \ref x86::Vec register instead of a general-purpose register.
//!
//! AsmJit allows to encode and work with all forms of addresses mentioned and
//! implemented by X86. In addition, it also allows to construct absolute 64-bit
//! memory address operands, which is only allowed in one form of 'mov' instruction.
//!
//! ```
//! #include <asmjit/x86.h>
//!
//! using namespace asmjit;
//!
//! void testX86Mem() {
//!   // Makes it easier to access x86 stuff...
//!   using namespace asmjit::x86;
//!
//!   // BASE + OFFSET.
//!   Mem a = ptr(rax);                 // a = [rax]
//!   Mem b = ptr(rax, 15);             // b = [rax + 15]
//!
//!   // BASE + INDEX << SHIFT - Shift is in BITS as used by X86!
//!   Mem c = ptr(rax, rbx);            // c = [rax + rbx]
//!   Mem d = ptr(rax, rbx, 2);         // d = [rax + rbx << 2]
//!   Mem e = ptr(rax, rbx, 2, 15);     // e = [rax + rbx << 2 + 15]
//!
//!   // BASE + VM (Vector Index) (encoded as MOD+VSIB).
//!   Mem f = ptr(rax, xmm1);           // f = [rax + xmm1]
//!   Mem g = ptr(rax, xmm1, 2);        // g = [rax + xmm1 << 2]
//!   Mem h = ptr(rax, xmm1, 2, 15);    // h = [rax + xmm1 << 2 + 15]
//!
//!   // Absolute adddress:
//!   uint64_t addr = (uint64_t)0x1234;
//!   Mem i = ptr(addr);                // i = [0x1234]
//!   Mem j = ptr(addr, rbx);           // j = [0x1234 + rbx]
//!   Mem k = ptr(addr, rbx, 2);        // k = [0x1234 + rbx << 2]
//!
//!   // LABEL - Will be encoded as RIP (64-bit) or absolute address (32-bit).
//!   Label L = ...;
//!   Mem m = ptr(L);                   // m = [L]
//!   Mem n = ptr(L, rbx);              // n = [L + rbx]
//!   Mem o = ptr(L, rbx, 2);           // o = [L + rbx << 2]
//!   Mem p = ptr(L, rbx, 2, 15);       // p = [L + rbx << 2 + 15]
//!
//!   // RIP - 64-bit only (RIP can't use INDEX).
//!   Mem q = ptr(rip, 24);             // q = [rip + 24]
//! }
//! ```
//!
//! Memory operands can optionally contain memory size. This is required by
//! instructions where the memory size cannot be deduced from other operands,
//! like `inc` and `dec` on X86:
//!
//! ```
//! #include <asmjit/x86.h>
//!
//! using namespace asmjit;
//!
//! void testX86Mem() {
//!   // The same as: dword ptr [rax + rbx].
//!   x86::Mem a = x86::dword_ptr(rax, rbx);
//!
//!   // The same as: qword ptr [rdx + rsi << 0 + 1].
//!   x86::Mem b = x86::qword_ptr(rdx, rsi, 0, 1);
//! }
//! ```
//!
//! Memory operands provide API that can be used to access its properties:
//!
//! ```
//! #include <asmjit/x86.h>
//!
//! using namespace asmjit;
//!
//! void testX86Mem() {
//!   // The same as: dword ptr [rax + 12].
//!   x86::Mem mem = x86::dword_ptr(rax, 12);
//!
//!   mem.hasBase();                    // true.
//!   mem.hasIndex();                   // false.
//!   mem.size();                       // 4.
//!   mem.offset();                     // 12.
//!
//!   mem.setSize(0);                   // Sets the size to 0 (makes it sizeless).
//!   mem.addOffset(-1);                // Adds -1 to the offset and makes it 11.
//!   mem.setOffset(0);                 // Sets the offset to 0.
//!   mem.setBase(rcx);                 // Changes BASE to RCX.
//!   mem.setIndex(rax);                // Changes INDEX to RAX.
//!   mem.hasIndex();                   // true.
//! }
//! // ...
//! ```
//!
//! Making changes to memory operand is very comfortable when emitting loads
//! and stores:
//!
//! ```
//! #include <asmjit/x86.h>
//!
//! using namespace asmjit;
//!
//! void testX86Mem() {
//!   x86::Assembler a(...);            // Your initialized x86::Assembler.
//!   x86::Mem mSrc = x86::ptr(eax);    // Construct [eax] memory operand.
//!
//!   // One way of emitting bunch of loads is to use `mem.adjusted()`, which
//!   // returns a new memory operand and keeps the source operand unchanged.
//!   a.movaps(x86::xmm0, mSrc);        // No adjustment needed to load [eax].
//!   a.movaps(x86::xmm1, mSrc.adjusted(16)); // Loads from [eax + 16].
//!   a.movaps(x86::xmm2, mSrc.adjusted(32)); // Loads from [eax + 32].
//!   a.movaps(x86::xmm3, mSrc.adjusted(48)); // Loads from [eax + 48].
//!
//!   // ... do something with xmm0-3 ...
//!
//!   // Another way of adjusting memory is to change the operand in-place.
//!   // If you want to keep the original operand you can simply clone it.
//!   x86::Mem mDst = mSrc.clone();     // Clone mSrc.
//!
//!   a.movaps(mDst, x86::xmm0);        // Stores xmm0 to [eax].
//!   mDst.addOffset(16);               // Adds 16 to `mDst`.
//!
//!   a.movaps(mDst, x86::xmm1);        // Stores to [eax + 16] .
//!   mDst.addOffset(16);               // Adds 16 to `mDst`.
//!
//!   a.movaps(mDst, x86::xmm2);        // Stores to [eax + 32].
//!   mDst.addOffset(16);               // Adds 16 to `mDst`.
//!
//!   a.movaps(mDst, x86::xmm3);        // Stores to [eax + 48].
//! }
//! ```
//!
//! ### Assembler Examples
//!
//!   - \ref x86::Assembler provides many X86/X64 examples.

// ============================================================================
// [Documentation - asmjit_builder]
// ============================================================================

//! \defgroup asmjit_builder Builder
//! \brief Builder interface, nodes, and passes.
//!
//! ### Overview
//!
//! Both \ref BaseBuilder and \ref BaseCompiler interfaces describe emitters
//! that emit into a representation that allows further processing. The code
//! stored in such representation is completely safe to be patched, simplified,
//! reordered, obfuscated, removed, injected, analyzed, or processed some other
//! way. Each instruction, label, directive, or other building block is stored
//! as \ref BaseNode (or derived class like \ref InstNode or \ref LabelNode)
//! and contains all the information necessary to pass that node later to the
//! assembler.
//!
//! \ref BaseBuilder is an emitter that inherits from \ref BaseEmitter interface.
//! It was designed to provide a maximum compatibility with the existing \ref
//! BaseAssembler emitter so users can move from assembler to builder when needed,
//! for example to implement post-processing, which is not possible with Assembler.
//!
//! \ref BaseBuilder doesn't generate machine code directly, it uses an intermediate
//! representation based on nodes, however, it allows to serialize to \ref BaseAssembler
//! when the code is ready to be encoded.
//!
//! There are multiple node types used by both \ref BaseBuilder and \ref BaseCompiler :
//!
//!   - Basic nodes:
//!     - \ref BaseNode - Base class for all nodes.
//!     - \ref InstNode - Represents an instruction node.
//!     - \ref AlignNode - Represents an alignment directive (.align).
//!     - \ref LabelNode - Represents a location where to bound a \ref Label.
//!
//!   - Data nodes:
//!     - \ref EmbedDataNode - Represents data.
//!     - \ref EmbedLabelNode - Represents \ref Label address embedded as data.
//!     - \ref EmbedLabelDeltaNode - Represents a difference of two labels
//!       embedded in data.
//!     - \ref ConstPoolNode - Represents a constant pool data embedded as data.
//!
//!   - Informative nodes:
//!     - \ref CommentNode - Represents a comment string, doesn't affect code
//!       generation.
//!     - \ref SentinelNode - A marker that can be used to remember certain
//!       position in code or data, doesn't affect code generation. Used by
//!       \ref FuncNode to mark the end of a function.
//!
//!   - Other nodes are provided by \ref asmjit_compiler infrastructure.
//!
//! ### Builder Examples
//!
//!   - \ref x86::Builder provides many X86/X64 examples.

// ============================================================================
// [Documentation - asmjit_compiler]
// ============================================================================

//! \defgroup asmjit_compiler Compiler
//! \brief Compiler interface.
//!
//! ### Overview
//!
//! \ref BaseCompiler is a high-level interface built on top of \ref BaseBuilder
//! interface, which provides register allocation and support for defining and
//! invoking functions. At the moment it's the easiest way of generating code
//! in AsmJit as most architecture and OS specifics is properly abstracted and
//! handled by AsmJit automatically. However, abstractions also mean restrictions,
//! which means that \ref BaseCompiler has more limitations that \ref BaseAssembler
//! or \ref BaseBuilder.
//!
//! Since \ref BaseCompiler provides register allocation it also establishes the
//! concept of functions - a function in Compiler sense is a unit in which virtual
//! registers are allocated into physical registers by the register allocator.
//! In addition, it enables to use such virtual registers in function invocations.
//!
//! \ref BaseCompiler automatically handles function calling conventions. It's
//! still architecture dependent, but makes the code generation much easies.
//! Functions are essential; the first-step to generate some code is to define a
//! signature of the function to be generated (before generating the function body
//! itself). Function arguments and return value(s) are handled by assigning
//! virtual registers to them. Similarly, function calls are handled the same way.
//!
//! \ref BaseCompiler adds some nodes that are required for function generation
//! and invocation:
//!
//!   - \ref FuncNode - Represents a function definition.
//!   - \ref FuncRetNode - Represents a function return.
//!   - \ref InvokeNode - Represents a function invocation.
//!
//! \ref BaseCompiler also makes the use of passes (\ref Pass) and automatically
//! adds an architecture-dependent register allocator pass to the list of passes
//! when attached to \ref CodeHolder.
//!
//! ### Compiler Examples
//!
//!   - \ref x86::Compiler provides many X86/X64 examples.

// ============================================================================
// [Documentation - asmjit_function]
// ============================================================================

//! \defgroup asmjit_function Function
//! \brief Function definitions.
//!
//! ### Overview
//!
//! AsmJit provides functionality that can be used to define function signatures
//! and to calculate automatically optimal function frame that can be used directly
//! by a prolog and epilog insertion. This feature was exclusive to AsmJit's Compiler
//! for a very long time, but was abstracted out and is now available for all users
//! regardless of the emitter they use. The design of handling functions prologs and
//! epilogs allows generally two use cases:
//!
//!   - Calculate function frame before the function is generated - this is the
//!     only way available to \ref BaseAssembler users and it will be described
//!     in this section.
//!
//!   - Calculate function frame after the function is generated - this way is
//!     generally used by \ref BaseBuilder and \ref BaseCompiler emitters and
//!     this way is generally described in \ref asmjit_compiler section.
//!
//! The following concepts are used to describe and create functions in AsmJit:
//!
//!   - \ref Type::Id - Type-id is an 8-bit value that describes a platform
//!     independent type as we know from C/C++. It provides abstractions for
//!     most common types like `int8_t`, `uint32_t`, `uintptr_t`, `float`,
//!     `double`, and all possible vector types to match ISAs up to AVX512.
//!     \ref Type::Id was introduced originally for \ref asmjit_compiler, but
//!     it's now used by \ref FuncSignature as well.
//!
//!   - \ref CallConv - Describes a calling convention - this class contains
//!     instructions to assign registers and stack addresses to function
//!     arguments and return value(s), but doesn't specify any function
//!     signature itself. Calling conventions are architecture and OS dependent.
//!
//!   - \ref FuncSignature - Describes a function signature, for example
//!     `int func(int, int)`. FuncSignature contains a function calling convention
//!     id, return value type, and function arguments. The signature itself is
//!     platform independent and uses \ref Type::Id to describe types of function
//!     arguments and function return value(s).
//!
//!   - \ref FuncDetail - Architecture and ABI dependent information that describes
//!     \ref CallConv and expanded \ref FuncSignature. Each function argument and
//!     return value is represented as \ref FuncValue that contains the original
//!     \ref Type::Id enriched with additional information that specifies whether
//!     the value is passed or returned by register (and which register) or by
//!     stack. Each value also contains some other metadata that provide additional
//!     information required to handle it properly (for example whether a vector is
//!     passed indirectly by a pointer as required by WIN64 calling convention).
//!
//!   - \ref FuncFrame - Contains information about the function frame that can
//!     be used by prolog/epilog inserter (PEI). Holds call stack size size and
//!     alignment, local stack size and alignment, and various attributes that
//!     describe how prolog and epilog should be constructed. `FuncFrame` doesn't
//!     know anything about function's arguments or return values, it hold only
//!     information necessary to create a valid and ABI conforming function prologs
//!     and epilogs.
//!
//!   - \ref FuncArgsAssignment - A helper class that can be used to reassign
//!     function arguments into user specified registers. It's architecture and
//!     ABI dependent mapping from function arguments described by \ref CallConv
//!     and \ref FuncDetail into registers specified by the user.
//!
//! It's a lot of concepts where each represents one step in a function frame
//! calculation. It can be used to create function prologs, epilogs, and also
//! to calculate information necessary to perform function calls.

// ============================================================================
// [Documentation - asmjit_logging]
// ============================================================================

//! \defgroup asmjit_logging Logging
//! \brief Logging and formatting.
//!
//! ### Overview
//!
//! The initial phase of a project that generates machine code is not always smooth.
//! Failure cases are common not just at the beginning phase, but also during the
//! development or refactoring. AsmJit provides logging functionality to address
//! this issue. AsmJit does already a good job with function overloading to prevent
//! from emitting unencodable instructions, but it can't prevent from emitting machine
//! code that is correct at instruction level, but doesn't work when it's executed as
//! a whole. Logging has always been an important part of AsmJit's infrastructure and
//! looking at logs can sometimes reveal code generation issues quickly.
//!
//! AsmJit provides API for logging and formatting:
//!   - \ref Logger - A logger that you can pass to \ref CodeHolder and all emitters
//!     that inherit from \ref BaseEmitter.
//!   - \ref FormatOptions - Formatting options that can change how instructions and
//!     operands are formatted.
//!   - \ref Formatter - A namespace that provides functions that can format input
//!     data like \ref Operand, \ref BaseReg, \ref Label, and \ref BaseNode into
//!     \ref String.
//!
//! AsmJit's \ref Logger serves the following purposes:
//!   - Provides a basic foundation for logging.
//!   - Abstract class leaving the implementation on users. The following built-in
//!     inplementations are provided for simplicty:
//!     - \ref FileLogger implements logging into a standard `FILE` stream.
//!     - \ref StringLogger serializes all logs into a \ref String instance.
//!
//! AsmJit's \ref FormatOptions provides the following to customize the formatting of
//! instructions and operands through:
//!   - \ref FormatOptions::Flags
//!   - \ref FormatOptions::IndentationType
//!
//! ### Logging
//!
//! A \ref Logger is typically attached to a \ref CodeHolder, which propagates it
//! to all attached emitters automatically. The example below illustrates how to
//! use \ref FileLogger that outputs to standard output:
//!
//! ```
//! #include <asmjit/core.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! int main() {
//!   JitRuntime rt;             // Runtime specialized for JIT code execution.
//!   FileLogger logger(stdout); // Logger should always survive CodeHolder.
//!
//!   CodeHolder code;           // Holds code and relocation information.
//!   code.init(rt.codeInfo());  // Initialize to the same arch as JIT runtime.
//!   code.setLogger(&logger);   // Attach the `logger` to `code` holder.
//!
//!   // ... code as usual, everything emitted will be logged to `stdout` ...
//!   return 0;
//! }
//! ```
//!
//! If output to FILE stream is not desired it's possible to use \ref StringLogger,
//! which concatenates everything into a multi-line string:
//!
//! ```
//! #include <asmjit/core.h>
//! #include <stdio.h>
//! #include <utility>
//!
//! using namespace asmjit;
//!
//! int main() {
//!   JitRuntime rt;             // Runtime specialized for JIT code execution.
//!   StringLogger logger;       // Logger should always survive CodeHolder.
//!
//!   CodeHolder code;           // Holds code and relocation information.
//!   code.init(rt.codeInfo());  // Initialize to the same arch as JIT runtime.
//!   code.setLogger(&logger);   // Attach the `logger` to `code` holder.
//!
//!   // ... code as usual, logging will be concatenated to logger string  ...
//!
//!   // You can either use the string from StringLogger directly or you can
//!   // move it. Logger::data() returns its content as null terminated char[].
//!   printf("Logger content: %s\n", logger.data());
//!
//!   // It can be moved into your own string like this:
//!   String content = std::move(logger.content());
//!   printf("The same content: %s\n", content.data());
//!
//!   return 0;
//! }
//! ```
//!
//! ### Formatting
//!
//! AsmJit uses \ref Formatter to format inputs that are then passed to \ref
//! Logger. Formatting is public and can be used by AsmJit users as well. The
//! most important thing to know regarding formatting is that \ref Formatter
//! always appends to the output string, so it can be used to build complex
//! strings without having to concatenate intermediate strings.
//!
//! The first example illustrates how to format operands:
//!
//! ```
//! #include <asmjit/core.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! void logOperand(uint32_t archId, const Operand_& op) {
//!   // The emitter is optional (named labels and virtual registers need it).
//!   BaseEmitter* emitter = nullptr;
//!
//!   // No flags by default.
//!   uint32_t formatFlags = FormatOptions::kNoFlags;
//!
//!   StringTmp<128> sb;
//!   Formatter::formatOperand(sb, formatFlags, emitter, archId, op);
//!   printf("%s\n", sb.data());
//! }
//!
//! void formattingExample() {
//!   using namespace x86;
//!
//!   // Architecture is not part of operand, it must be passed explicitly.
//!   // Format flags. We pass it explicitly also to 'logOperand' to make
//!   // compatible with what AsmJit normally does.
//!   uint32_t archId = ArchInfo::kIdX64;
//!
//!   log(archId, rax);                    // Prints 'rax'.
//!   log(archId, ptr(rax, rbx, 2));       // Prints '[rax + rbx * 4]`.
//!   log(archId, dword_ptr(rax, rbx, 2)); // Prints 'dword [rax + rbx * 4]`.
//!   log(archId, imm(42));                // Prints '42'.
//! }
//! ```
//!
//! Next example illustrates how to format whole instructions:
//!
//! ```
//! #include <asmjit/core.h>
//! #include <stdio.h>
//! #include <utility>
//!
//! using namespace asmjit;
//!
//! template<typename... Args>
//! void logInstruction(uint32_t archId, const BaseInst& inst, Args&&... args) {
//!   // The emitter is optional (named labels and virtual registers need it).
//!   BaseEmitter* emitter = nullptr;
//!
//!   // No flags by default.
//!   uint32_t formatFlags = FormatOptions::kNoFlags;
//!
//!   // The formatter expects operands in an array.
//!   Operand_ operands { std::forward<Args>(args)... };
//!
//!   StringTmp<128> sb;
//!   Formatter::formatInstruction(
//!     sb, formatFlags, emitter, archId, inst, operands, sizeof...(args));
//!   printf("%s\n", sb.data());
//! }
//!
//! void formattingExample() {
//!   using namespace x86;
//!
//!   // Architecture is not part of operand, it must be passed explicitly.
//!   // Format flags. We pass it explicitly also to 'logOperand' to make
//!   // compatible with what AsmJit normally does.
//!   uint32_t archId = ArchInfo::kIdX64;
//!
//!   // Prints 'mov rax, rcx'.
//!   logInstruction(archId, BaseInst(Inst::kIdMov), rax, rcx);
//!
//!   // Prints 'vaddpd zmm0, zmm1, [rax] {1to8}'.
//!   logInstruction(archId,
//!                  BaseInst(Inst::kIdVaddpd),
//!                  zmm0, zmm1, ptr(rax)._1toN());
//!
//!   // BaseInst abstracts instruction id, instruction options, and extraReg.
//!   // Prints 'lock add [rax], rcx'.
//!   logInstruction(archId,
//!                  BaseInst(Inst::kIdAdd, Inst::kOptionLock),
//!                  x86::ptr(rax), rcx);
//!
//!   // Similarly an extra register (like AVX-512 selector) can be used.
//!   // Prints 'vaddpd zmm0 {k2} {z}, zmm1, [rax]'.
//!   logInstruction(archId,
//!                  BaseInst(Inst::kIdAdd, Inst::kOptionZMask, k2),
//!                  zmm0, zmm1, ptr(rax));
//! }
//! ```
//!
//! And finally, the example below illustrates how to use a built-in function
//! to format the content of \ref BaseBuilder, which consists of nodes:
//!
//! ```
//! #include <asmjit/core.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! void formattingExample(BaseBuilder* builder) {
//!   uint32_t formatFlags = FormatOptions::kNoFlags;
//!
//!   // This also shows how temporary strings can be used.
//!   StringTmp<512> sb;
//!
//!   // FormatNodeList requires the String for output, formatting flags, which
//!   // were zero (no extra flags), and the builder instance, which we have
//!   // provided. An overloaded version also exists, which accepts begin and
//!   // and end nodes, which can be used to only format a range of nodes.
//!   Formatter::formatNodeList(sb, formatFlags, builder);
//!
//!   // You can do whatever else with the string, it's always null terminated,
//!   // so it can be passed to C functions like printf().
//!   printf("%s\n", sb.data());
//! }
//! ```

// ============================================================================
// [Documentation - asmjit_error_handling]
// ============================================================================

//! \defgroup asmjit_error_handling Error Handling
//! \brief Error handling.
//!
//! ### Overview
//!
//! AsmJit uses error codes to represent and return errors. Every function that
//! can fail returns an \ref Error code. Exceptions are never thrown by AsmJit
//! itself even in extreme conditions like out-of-memory, but it's possible to
//! override \ref ErrorHandler::handleError() to throw, in that case no error
//! will be returned and exception will be thrown instead. All functions where
//! this can happen are not marked `noexcept`.
//!
//! Errors should never be ignored, however, checking errors after each AsmJit
//! API call would simply overcomplicate the whole code generation experience.
//! \ref ErrorHandler exists to make the use of AsmJit API simpler as it allows
//! to customize how errors can be handled:
//!
//!   - Record the error and continue (the way how the error is user-implemented).
//!   - Throw an exception. AsmJit doesn't use exceptions and is completely
//!     exception-safe, but it's perfectly legal to throw an exception from
//!     the error handler.
//!   - Use plain old C's `setjmp()` and `longjmp()`. Asmjit always puts Assembler,
//!     Builder and Compiler to a consistent state before calling \ref
//!     ErrorHandler::handleError(), so `longjmp()` can be used without issues to
//!     cancel the code-generation if an error occurred. This method can be used if
//!     exception handling in your project is turned off and you still want some
//!     comfort. In most cases it should be safe as AsmJit uses \ref Zone memory
//!     and the ownership of memory it allocates always ends with the instance that
//!     allocated it. If using this approach please never jump outside the life-time
//!     of \ref CodeHolder and \ref BaseEmitter.
//!
//! ### Using ErrorHandler
//!
//! An example of attaching \ref ErrorHandler to \ref CodeHolder.
//!
//! ```
//! #include <asmjit/x86.h>
//! #include <stdio.h>
//!
//! using namespace asmjit;
//!
//! // A simple error handler implementation, extend according to your needs.
//! class MyErrorHandler : public ErrorHandler {
//! public:
//!   void handleError(Error err, const char* message, BaseEmitter* origin) override {
//!     printf("AsmJit error: %s\n", message);
//!   }
//! };
//!
//! int main() {
//!   JitRuntime rt;
//!
//!   MyErrorHandler myErrorHandler;
//!   CodeHolder code;
//!
//!   code.init(rt.codeInfo());
//!   code.setErrorHandler(&myErrorHandler);
//!
//!   x86::Assembler a(&code);
//!   // ... code generation ...
//!
//!   return 0;
//! }
//! ```
//!
//! Useful classes in error handling group:
//!
//!   - See \ref DebugUtils that provides utilities useful for debugging.
//!   - See \ref Error that lists error codes that AsmJit uses.
//!   - See \ref ErrorHandler for more details about error handling.

// ============================================================================
// [Documentation - asmjit_instruction_db]
// ============================================================================

//! \defgroup asmjit_instruction_db Instruction DB
//! \brief Instruction database (introspection, read/write, validation, ...).
//!
//! ### Overview
//!
//! AsmJit provides a public instruction database that can be used to query
//! information about a complete instruction. The instruction database requires
//! the following:
//!
//!   - \ref ArchInfo - Information about target architecture.
//!   - \ref BaseInst - Base instruction that contains instruction id, options,
//!     and a possible extra-register.
//!   - \ref Operand - Represents operands the instruction uses.
//!
//! Each instruction can be then queried for the following information:
//!
//!   - \ref InstRWInfo - Read/write information of instruction and its oprands.
//!   - \ref OpRWInfo - Read/write information of a single operand, part of
//!     \ref InstRWInfo data structure.
//!   - \ref BaseFeatures - CPU features required to execute the instruction.
//!
//! In addition to query functionality AsmJit is also able to validate whether
//! an instruction and its operands are valid. This is useful for making sure
//! that what user tries to emit is correct and it can be also used by other
//! projects that parse user input, like AsmTK project.
//!
//! ### Query API
//!
//! The instruction query API is provided by \ref InstAPI namespace.
//!
//! TODO: Missing documentation
//!
//! ### Validation API
//!
//! TODO: Missing documentation


// ============================================================================
// [Documentation - asmjit_virtual_memory]
// ============================================================================

//! \defgroup asmjit_virtual_memory Virtual Memory
//! \brief Virtual memory management.
//!
//! ### Overview
//!
//! AsmJit's virtual memory management is divided into two main categories:
//!
//!   - Low level API that provides cross-platform abstractions for virtual
//!     memory allocation. Implemented in \ref VirtMem namespace.
//!   - High level API that makes it very easy to store generated code for
//!     execution. See \ref JitRuntime, which is used by many examples for its
//!     simplicity and easy integration with \ref CodeHolder. There is also
//!     \ref JitAllocator, which lays somewhere between RAW memory allocation
//!     and \ref JitRuntime.

// ============================================================================
// [Documentation - asmjit_zone_memory]
// ============================================================================

//! \defgroup asmjit_zone Zone Memory
//! \brief Zone memory allocator and containers.
//!
//! ### Overview
//!
//! AsmJit uses zone memory allocation (also known as Arena allocation) to allocate
//! most of the data it uses. It's a fast allocator that allows AsmJit to allocate
//! a lot of small data structures fast and without `malloc()` overhead. Since
//! code generators and all related classes are usually short-lived this approach
//! decreases memory usage and fragmentation as arena-based allocators always
//! allocate larger blocks of memory, which are then split into smaller chunks.
//!
//! Another advantage of zone memory allocation is that since the whole library
//! uses this strategy it's very easy to deallocate everything that a particular
//! instance is holding by simply releasing the memory the allocator holds. This
//! improves destruction time of such objects as there is no destruction at all.
//! Long-lived objects just reset its data in destructor or in their reset()
//! member function for a future reuse. For this purpose all containers in AsmJit
//! are also zone allocated.
//!
//! ### Zone Allocation
//!
//!   - \ref Zone - Incremental zone memory allocator with minimum features. It
//!     can only allocate memory without the possibility to return it back to
//!     the allocator.
//!
//!   - \ref ZoneTmp - A temporary \ref Zone with some initial static storage.
//!     If the allocation requests fit the static storage allocated then there
//!     will be no dynamic memory allocation during the lifetime of \ref ZoneTmp,
//!     otherwise it would act as \ref Zone with one preallocated block on the
//!     stack.
//!
//!   - \ref ZoneAllocator - A wrapper of \ref Zone that provides the capability
//!     of returning memory to the allocator. Such memory is stored in a pool for
//!     later reuse.
//!
//! ### Zone Allocated Containers
//!
//!   - \ref ZoneString - Zone allocated string.
//!   - \ref ZoneHash - Zone allocated hash table.
//!   - \ref ZoneTree - Zone allocated red-black tree.
//!   - \ref ZoneList - Zone allocated double-linked list.
//!   - \ref ZoneStack - Zone allocated stack.
//!   - \ref ZoneVector - Zone allocated vector.
//!   - \ref ZoneBitVector - Zone allocated vector of bits.
//!
//! ### Using Zone Allocated Containers
//!
//! The most common data structure exposed by AsmJit is \ref ZoneVector. It's very
//! similar to `std::vector`, but the implementation doesn't use exceptions and
//! uses the mentioned \ref ZoneAllocator for performance reasons. You don't have
//! to worry about allocations as you should not need to add items to AsmJit's
//! data structures directly as there should be API for all required operations.
//!
//! The following APIs in \ref CodeHolder returns \ref ZoneVector reference:
//!
//! ```
//! using namespace asmjit;
//!
//! void example(CodeHolder& code) {
//!   // Contains all emitters attached to CodeHolder.
//!   const ZoneVector<BaseEmitter*>& emitters = code.emitters();
//!
//!   // Contains all section entries managed by CodeHolder.
//!   const ZoneVector<Section*>& sections = code.sections();
//!
//!   // Contains all label entries managed by CodeHolder.
//!   const ZoneVector<LabelEntry*>& labelEntries = code.labelEntries();
//!
//!   // Contains all relocation entries managed by CodeHolder.
//!   const ZoneVector<RelocEntry*>& relocEntries = code.relocEntries();
//! }
//! ```
//!
//! \ref ZoneVector has overloaded array access operator to make it possible
//! to access its elements through operator[]. Some standard functions like
//! \ref ZoneVector::empty(), \ref ZoneVector::size(), and \ref ZoneVector::data()
//! are provided as well. Vectors are also iterable through a range-based for loop:
//!
//! ```
//! using namespace asmjit;
//!
//! void example(CodeHolder& code) {
//!   for (LabelEntry* le : code.labelEntries()) {
//!     printf("Label #%u {Bound=%s Offset=%llu}",
//!       le->id(),
//!       le->isBound() ? "true" : "false",
//!       (unsigned long long)le->offset());
//!   }
//! }
//! ```
//!
//! ### Design Considerations
//!
//! Zone-allocated containers do not store the allocator within the container.
//! This decision was made to reduce the footprint of such containers as AsmJit
//! tooling, especially Compiler's register allocation, may use many instances
//! of such containers to perform code analysis and register allocation.
//!
//! For example to append an item into a \ref ZoneVector it's required to pass
//! the allocator as the first argument, so it can be used in case that the
//! vector needs a reallocation. Such function also returns an error, which
//! must be propagated to the caller.
//!
//! ```
//! using namespace asmjit
//!
//! Error example(ZoneAllocator* allocator) {
//!   ZoneVector<int> vector;
//!
//!   // Unfortunately, allocator must be provided to all functions that mutate
//!   // the vector. However, AsmJit users should never need to do this as all
//!   // manipulation should be done through public API, which takes care of
//!   // that.
//!   for (int i = 0; i < 100; i++) {
//!     ASMJIT_PROPAGATE(vector.append(allocator, i));
//!   }
//!
//!   // By default vector's destructor doesn't release anything as it knows
//!   // that its content is zone allocated. However, \ref ZoneVector::release
//!   // can be used to explicitly release the vector data to the allocator if
//!   // necessary
//!   vector.release(allocator);
//! }
//! ```
//!
//! Containers like \ref ZoneVector also provide a functionality to reserve a
//! certain number of items before any items are added to it. This approach is
//! used internally in most places as it allows to prepare space for data that
//! will be added to some container before the data itself was created.
//!
//! ```
//! using namespace asmjit
//!
//! Error example(ZoneAllocator* allocator) {
//!   ZoneVector<int> vector;
//!
//!   ASMJIT_PROPAGATE(vector.willGrow(100));
//!   for (int i = 0; i < 100; i++) {
//!     // Cannot fail.
//!     vector.appendUnsafe(allocator, i);
//!   }
//!
//!   vector.release(allocator);
//! }
//! ```

// ============================================================================
// [Documentation - asmjit_utilities]
// ============================================================================

//! \defgroup asmjit_utilities Utilities
//! \brief Utility classes and functions.
//!
//! ### Overview
//!
//! AsmJit uses and provides utility classes and functions, that can be used
//! with AsmJit. The functionality can be divided into the following topics:
//!
//! ### String Functionality
//!
//!   - \ref String - AsmJit's string container, which is used internally
//!     and which doesn't use exceptions and has a stable layout, which is
//!     not dependent on C++ standard library.
//!   - \ref StringTmp - String that can have base storage allocated on
//!     stack. The amount of storage on stack can be specified as a template
//!     parameter.
//!   - \ref FixedString - Fixed string container limited up to N characters.
//!
//! ### Code Generation Utilities
//!
//!   - \ref ConstPool - Constant pool used by \ref BaseCompiler, but also
//!     available to users that may find use of it.
//!
//! ### Support Functionality Used by AsmJit
//!
//!   - \ref Support namespace provides many other utility functions and
//!     classes that are used by AsmJit, and made public.

// ============================================================================
// [Documentation - asmjit_ra]
// ============================================================================

//! \cond INTERNAL
//! \defgroup asmjit_ra RA
//! \brief Register allocator internals.
//! \endcond

} // {asmjit}

// ============================================================================
// [Core Headers]
// ============================================================================

#include "./core/globals.h"

#include "./core/arch.h"
#include "./core/assembler.h"
#include "./core/builder.h"
#include "./core/callconv.h"
#include "./core/codeholder.h"
#include "./core/compiler.h"
#include "./core/constpool.h"
#include "./core/cpuinfo.h"
#include "./core/datatypes.h"
#include "./core/emitter.h"
#include "./core/errorhandler.h"
#include "./core/features.h"
#include "./core/formatter.h"
#include "./core/func.h"
#include "./core/inst.h"
#include "./core/jitallocator.h"
#include "./core/jitruntime.h"
#include "./core/logger.h"
#include "./core/operand.h"
#include "./core/osutils.h"
#include "./core/string.h"
#include "./core/support.h"
#include "./core/target.h"
#include "./core/type.h"
#include "./core/virtmem.h"
#include "./core/zone.h"
#include "./core/zonehash.h"
#include "./core/zonelist.h"
#include "./core/zonetree.h"
#include "./core/zonestack.h"
#include "./core/zonestring.h"
#include "./core/zonevector.h"

// ============================================================================
// [Deprecated]
// ============================================================================

#ifndef ASMJIT_NO_DEPRECATED
namespace asmjit {

ASMJIT_DEPRECATED("Use InvokeNode instead of FuncCallNode")
typedef InvokeNode FuncCallNode;

namespace Logging { using namespace Formatter; }

} // {asmjit}
#endif // !ASMJIT_NO_DEPRECATED

#endif // ASMJIT_CORE_H_INCLUDED
